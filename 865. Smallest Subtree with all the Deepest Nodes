//    Difficulty : Medium


//  Problem  

//    Given the root of a binary tree, the depth of each node is the shortest distance to the root.
//    Return the smallest subtree such that it contains all the deepest nodes in the original tree.
//    A node is called the deepest if it has the largest depth possible among any node in the entire tree.
//    The subtree of a node is a tree consisting of that node, plus the set of all descendants of that node.


//    Approch

//    ðŸ§  Approach (Short â€“ GitHub Ready)
//    Use DFS to compute the depth of left and right subtrees for every node.
//    Track the maximum depth (height) found so far.
//    At each node:
//    If left depth == right depth and this depth is â‰¥ current max depth, then this node can be the root of the smallest subtree containing all deepest nodes.
//    Update the answer node (x) accordingly.
//    Finally, return x.




//    Solution

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    static TreeNode x;
    static int height=0;
    public TreeNode subtreeWithAllDeepest(TreeNode root) {
        x=root;
        height=Integer.MIN_VALUE;
        int n=dfs(root,0);
        return  x;
    }
    public int dfs(TreeNode root,int i){
        if(root == null) return i;
        int l=dfs(root.left,i+1);
        int r=dfs(root.right,i+1);
        int h=Math.max(l,r);
        if(l==r&&height<=h){
            height=h;
            x=root;
            // System.out.println(l+" "+r+" "+h);
        }
        return h;
    }
}
